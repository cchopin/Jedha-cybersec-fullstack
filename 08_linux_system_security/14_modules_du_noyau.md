# Les modules du noyau

**Durée : 50 min**

## Ce que vous allez apprendre dans ce cours

Bien que le noyau Linux soit un monolithe, son architecture permet d'insérer de nouvelles fonctionnalités à l'exécution via des modules. C'est à la fois une commodité et un risque : les modules étendent les capacités du noyau, mais ils introduisent aussi une voie pour les erreurs ou les attaques.

Dans cette leçon, vous apprendrez :

- ce que sont les modules du noyau,
- comment visualiser, charger et supprimer des modules,
- les risques de sécurité posés par les modules chargeables,
- comment se défendre contre ces risques.

À la fin, vous comprendrez pourquoi un module est comme une clé USB pour votre noyau : utile, mais vous devriez vraiment savoir d'où il vient.

---

## Qu'est-ce qu'un module du noyau ?

Les modules du noyau sont des fichiers objets (format binaire lisible par la machine) avec l'extension `.ko` qui peuvent être insérés dans le noyau Linux en cours d'exécution pour étendre ses capacités. Ils permettent au noyau de supporter du matériel, systèmes de fichiers ou protocoles supplémentaires sans recompilation ou redémarrage.

### Caractéristiques des modules

| Caractéristique | Description |
|-----------------|-------------|
| **Écrits en C** | Compilés séparément du noyau de base |
| **Interface avec le noyau** | Utilisent des API définies et peuvent enregistrer des hooks ou appels système |
| **Stockage** | Stockés dans `/lib/modules/<kernel-version>/` |
| **Chargement automatique** | Chargés automatiquement quand le système détecte le besoin |

### Cas d'usage pour les modules personnalisés

Dans la plupart des cas, les utilisateurs n'ont pas besoin d'ajouter manuellement des modules. Cependant, vous pourriez installer ou compiler un module personnalisé si :

- Vous utilisez du matériel peu commun ou de pointe pas encore supporté par le noyau par défaut
- Vous développez un pilote personnalisé ou une extension noyau
- Vous voulez charger un module tiers pour une surveillance avancée, sécurité ou support de système de fichiers
- Vous travaillez sur un système minimaliste ou embarqué qui exclut les pilotes non essentiels par défaut

### Risque de sécurité

Les modules chargés deviennent partie de l'espace mémoire du noyau et s'exécutent avec les **privilèges complets du noyau**. Cela signifie que tout bug ou backdoor dans un module compromet le système entier, faisant de la gestion des modules une partie clé de la sécurité du noyau.

---

## Gérer les modules du noyau

Linux fournit plusieurs outils pour interagir avec les modules du noyau. Ces commandes vous permettent de voir ce qui est chargé, obtenir les détails des modules et insérer ou supprimer manuellement des modules.

### lsmod - Lister les modules chargés

Cette commande liste tous les modules actuellement chargés :

```bash
$ lsmod
Module                  Size  Used by
tls                   159744  0
isofs                  57344  1
snd_seq_dummy          12288  0
qrtr                   49152  2
vsock_loopback         12288  0
videodev              368640  2 videobuf2_v4l2,uvcvideo
```

**La colonne "Used by" indique :**
- `0` : le module est inactif et peut être supprimé
- `>1 avec noms de modules` : le module est utilisé par un ou plusieurs modules listés
- `>1 sans détail` : le module est utilisé par d'autres composants comme des pilotes liés au matériel

Vous pouvez aussi accéder aux fichiers système : `cat /proc/modules` donnera une liste similaire.

**Utilité de lsmod :**
- Voir rapidement quels modules noyau sont actifs
- Résoudre des problèmes de matériel ou pilotes
- Détecter des modules malveillants ou rootkits

### modinfo - Informations sur un module

Cette commande affiche les métadonnées d'un module, incluant auteur, licence, version, description et paramètres acceptés :

```bash
$ modinfo qrtr
filename:       /lib/modules/6.8.0-60-generic/kernel/net/qrtr/qrtr.ko.zst
alias:          net-pf-42
license:        GPL v2
description:    Qualcomm IPC-router driver
srcversion:     36E2B937314F0DA85B55EFD
depends:
intree:         Y
name:           qrtr
vermagic:       6.8.0-60-generic SMP preempt mod_unload modversions aarch64
sig_id:         PKCS#7
signer:         Build time autogenerated kernel key
sig_key:        1B:2C:52:6A:14:1C:36:35:94:9B:84:0E:D0:1E:EE:31:80:D5:DD:71
sig_hashalgo:   sha512
signature:      7B:06:84:3D:4A:44:AA:6C:49:24:A1:B6:2C:02:C3:BC...
```

**Utilité de modinfo :**
- Vérifier pour quelle version du noyau un module est compilé
- Voir les paramètres chargeables pour personnaliser le comportement dans `/etc/modprobe.d/`
- Du point de vue sécurité, révéler la licence, l'auteur et le statut de signature du module

### modprobe - Charger un module

Cette commande charge un module et résout toutes les dépendances. Elle cherche les modules dans `/lib/modules/` et lit les fichiers de configuration dans `/etc/modprobe.d/`. C'est la méthode préférée pour insérer des modules :

```bash
# Charger le module dummy
$ sudo modprobe dummy
$ lsmod | grep dummy
dummy                  12288  0

# Décharger et recharger avec un paramètre
$ sudo modprobe -r dummy
$ sudo modprobe -v dummy numdummies=1

# Vérifier l'effet
$ ip link
3: dummy0: <BROADCAST,NOARP> mtu 1500 qdisc noop state DOWN...
```

Pour rendre ce comportement permanent, ajoutez une config dans `/etc/modprobe.d/dummy.conf` :

```
options dummy numdummies=2
```

### rmmod - Supprimer un module

`rmmod` supprime un module du noyau. Contrairement à `modprobe -r` qui supprime le module spécifié et tous les modules qui en dépendent, `rmmod` échoue si un autre module utilise celui que vous essayez de supprimer :

```bash
sudo rmmod dummy
```

### insmod - Insertion directe

`insmod` insère directement un module du noyau dans le noyau en cours d'exécution. Il prend le chemin exact vers le fichier module et le charge sans vérifier les dépendances ou configuration :

```bash
sudo insmod /lib/modules/6.8.0-60-generic/kernel/drivers/net/dummy.ko.zst
```

> **Note** : Vous avez peut-être remarqué l'extension `.ko.zst` au lieu de `.ko` : les systèmes Ubuntu et Debian modernes compressent maintenant les modules noyau avec Zstandard pour économiser de l'espace disque.

En pratique, `modprobe` est presque toujours le choix le plus sûr. `insmod` peut être utile pour les tests et le débogage.

---

## Fichiers et dossiers importants

### Chargement automatique au démarrage

Vous pouvez configurer les modules pour qu'ils se chargent automatiquement au démarrage en créant des fichiers `.conf` dans `/etc/modules-load.d/` :

```bash
$ sudo nano /etc/modules-load.d/dummy.conf
# Contenu : juste le nom du module
dummy
```

Pour appliquer cette configuration :

```bash
sudo systemctl restart systemd-modules-load
```

### Structure de /lib/modules/<kernel_version>/

```bash
ll /lib/modules/6.8.0-60-generic/
```

| Répertoire/Fichier | Description |
|--------------------|-------------|
| `kernel/` | Les modules réels organisés par sous-systèmes (ex: `drivers/net`, `fs/`, `crypto/`) |
| `modules.dep` | Fichier listant les dépendances des modules |
| `modules.alias` | Fichier mappant les alias de périphériques aux noms de modules |
| `modules.builtin` | Liste des modules compilés directement dans le noyau |
| `modules.softdep`, `modules.symbols` | Fichiers aidant à gérer le comportement de chargement |

### Résumé des chemins

| Chemin/Fichier | But |
|----------------|-----|
| `/lib/modules/<kernel-version>/` | Contient tous les modules noyau et métadonnées |
| `/etc/modules-load.d/` | Configuration systemd pour les modules à charger au démarrage |
| `/etc/modprobe.d/` | Configuration pour les paramètres de modules, blacklists et alias |
| `/proc/modules` | Modules actuellement chargés, mis à jour en temps réel |
| `/sys/module/` | Répertoire noyau exposant les détails des modules chargés |

---

## Sécuriser les modules du noyau

Les modules du noyau s'exécutent avec les privilèges complets du noyau. Cela signifie que tout module, qu'il soit officiel, tiers ou malveillant, a le même pouvoir que le noyau lui-même. Un module mal écrit ou compromis peut planter le système, fuiter des données sensibles ou créer des backdoors invisibles aux outils de sécurité traditionnels.

### Qu'est-ce qu'un rootkit ?

Un **rootkit** est un type de logiciel malveillant conçu pour cacher sa présence et maintenir un accès privilégié sur un système. Dans le contexte des modules noyau, un **rootkit noyau** est un module qui s'accroche au noyau ou en remplace des parties pour manipuler le comportement du système.

Un rootkit noyau peut :
- Cacher des fichiers, processus ou connexions réseau aux outils userspace comme `ps`, `ls` ou `netstat`
- Intercepter et modifier les appels système pour filtrer les traces d'activité malveillante
- Logger ou détourner des informations sensibles comme les mots de passe ou sessions SSH
- Désactiver ou tromper les outils de sécurité

### Durcissement du noyau

#### Désactiver le chargement de modules

Le paramètre sysctl `kernel.modules_disabled` est un paramètre noyau runtime qui, quand il est mis à 1, désactive tout chargement ou déchargement futur de modules pour le reste de la durée de fonctionnement du système :

```bash
echo 1 | sudo tee /proc/sys/kernel/modules_disabled
```

Une fois fait :
- `insmod`, `modprobe` et `rmmod` échoueront silencieusement ou avec une erreur de permission
- Aucun nouveau module ne peut être inséré, même par root
- Cela ne peut pas être inversé sans redémarrer le système

#### Signature des modules

Un autre problème de sécurité est les modules non signés. Sans signature cryptographique, il n'y a aucun moyen pour le noyau de vérifier qui a compilé le module, s'il a été modifié ou s'il provient d'une source de confiance.

Pour vérifier si votre noyau supporte/applique la signature des modules :

```bash
$ grep CONFIG_MODULE_SIG /boot/config-$(uname -r)
CONFIG_MODULE_SIG_FORMAT=y
CONFIG_MODULE_SIG=y
# CONFIG_MODULE_SIG_FORCE is not set
```

| Configuration | Description |
|---------------|-------------|
| `CONFIG_MODULE_SIG=y` | Le noyau supporte la signature des modules |
| `CONFIG_MODULE_SIG_FORCE` non défini | Le noyau vérifiera et loggera si un module est signé, mais chargera les modules non signés |

> **Note** : Si Secure Boot est activé, le noyau entre typiquement en mode lockdown et rejettera les modules non signés quel que soit ce paramètre.

### Blacklister les modules inutiles ou risqués

Le blacklisting empêche des modules noyau spécifiques d'être chargés, soit automatiquement au démarrage soit manuellement par un utilisateur.

```bash
$ cat /etc/modprobe.d/blacklist-firewire.conf
# Blacklister les modules firewire legacy
blacklist ohci1394
blacklist sbp2
blacklist dv1394
```

**Exemples de modules à blacklister dans les environnements durcis :**

| Module | Raison |
|--------|--------|
| `usb_storage` | Bloque l'accès non autorisé aux périphériques USB |
| `firewire_ohci` | Empêche les attaques DMA FireWire |
| `bluetooth` | Inutile sur les serveurs, vecteur d'attaque potentiel |
| `cramfs`, `hfs`, `jffs2` | Systèmes de fichiers rarement utilisés pouvant être exploités |

Pour appliquer les changements, redémarrez ou déchargez manuellement les modules actuellement chargés.

### Auditer et surveiller l'activité des modules

Même si vous ne pouvez pas tout bloquer, vous pouvez détecter et répondre aux activités suspectes de modules.

**Surveiller les logs :**

```bash
journalctl -k | grep module
dmesg | grep -i "module"
```

**Avec auditd :**

```bash
# Suivre l'accès aux chemins sensibles des modules
$ sudo auditctl -w /lib/modules/ -p rwxa -k module_store

# Suivre l'insertion et la suppression de modules
$ sudo auditctl -a always,exit -F arch=b64 -S init_module -k mod_insert

# Charger un module pour tester
$ sudo modprobe dummy

# Rechercher les événements
$ sudo ausearch -k mod_insert
```

Vous pouvez aussi utiliser un vérificateur d'intégrité de fichiers comme AIDE pour surveiller les changements dans `/lib/modules/`.

### Contrôle d'accès obligatoire (MAC)

Au-delà de l'audit des appels système et de la signature des modules, les systèmes avancés utilisent des frameworks de contrôle d'accès obligatoire (MAC) comme **AppArmor** et **SELinux** pour restreindre qui peut interagir avec les modules noyau.

- **AppArmor** peut restreindre l'accès à des outils comme `modprobe`, `insmod` ou même `/lib/modules/` entièrement
- **SELinux** fournit un contrôle encore plus strict en utilisant des types et rôles

Nous parlerons plus de SELinux et AppArmor dans la prochaine leçon !

---

## Glossaire des sigles et définitions

| Sigle/Terme | Définition |
|-------------|------------|
| **Kernel module** | Module du noyau - Fichier .ko étendant les fonctionnalités du noyau |
| **lsmod** | List Modules - Commande pour lister les modules chargés |
| **modinfo** | Module Info - Commande pour afficher les informations d'un module |
| **modprobe** | Module Probe - Commande pour charger/décharger des modules avec dépendances |
| **insmod** | Insert Module - Commande pour insérer directement un module |
| **rmmod** | Remove Module - Commande pour supprimer un module |
| **Rootkit** | Logiciel malveillant qui cache sa présence et maintient un accès privilégié |
| **Blacklist** | Liste noire - Liste de modules à ne pas charger |
| **MAC** | Mandatory Access Control - Contrôle d'accès obligatoire |
| **Secure Boot** | Fonctionnalité UEFI qui vérifie les signatures au démarrage |
| **Module signing** | Signature de module - Vérification cryptographique de l'origine d'un module |

---

## Récapitulatif des commandes

### Visualisation des modules

| Commande | Description |
|----------|-------------|
| `lsmod` | Lister tous les modules chargés |
| `cat /proc/modules` | Liste alternative des modules chargés |
| `modinfo nom_module` | Afficher les informations d'un module |

### Chargement et déchargement

| Commande | Description |
|----------|-------------|
| `sudo modprobe nom_module` | Charger un module avec dépendances |
| `sudo modprobe -r nom_module` | Décharger un module et ses dépendances |
| `sudo modprobe -v nom param=valeur` | Charger avec paramètres |
| `sudo insmod /chemin/module.ko` | Charger directement un module |
| `sudo rmmod nom_module` | Supprimer un module |

### Sécurité et audit

| Commande | Description |
|----------|-------------|
| `echo 1 \| sudo tee /proc/sys/kernel/modules_disabled` | Désactiver le chargement de modules |
| `grep CONFIG_MODULE_SIG /boot/config-$(uname -r)` | Vérifier le support de signature |
| `sudo auditctl -w /lib/modules/ -p rwxa -k module_store` | Auditer l'accès aux modules |
| `sudo auditctl -a always,exit -F arch=b64 -S init_module -k mod_insert` | Auditer le chargement de modules |
| `sudo ausearch -k mod_insert` | Rechercher les événements d'audit |

### Fichiers de configuration

| Fichier | Description |
|---------|-------------|
| `/etc/modprobe.d/*.conf` | Configuration des modules (options, blacklist) |
| `/etc/modules-load.d/*.conf` | Modules à charger au démarrage |
| `/lib/modules/<version>/` | Emplacement des modules |

---

## Ressources

- Working with kernel modules - Red Hat Documentation
- Essential Guide for Securing the Linux Kernel Environment Effectively - Brittany Day
- Linux rootkits explained - Avigayil Mechtinger

### Ressources pratiques - TryHackMe / HackTheBox

| Plateforme | Room/Lab | Description |
|------------|----------|-------------|
| TryHackMe | [Linux Privilege Escalation](https://tryhackme.com/room/linprivesc) | Techniques incluant l'abus de modules |
| TryHackMe | [Linux Forensics](https://tryhackme.com/room/linuxforensics) | Investigation forensique Linux |
| TryHackMe | [RootMe](https://tryhackme.com/room/rrootme) | Élévation de privilèges |
| HackTheBox | [Machines Linux](https://app.hackthebox.com/machines) | Machines avec scénarios de rootkit |
